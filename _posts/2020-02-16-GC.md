---
layout: post
title: GC笔记
date: 2020-02-16
tags: tools
---



## java 内存模型（JMM）和垃圾回收（GC）

### JAVA内存模型

![image](https://user-images.githubusercontent.com/39090338/79426704-1b9a4980-7ff6-11ea-9d1c-32ccea6040c1.png)

JAVA内存模型分为虚拟机栈、本地方法栈、程序计数器、堆和方法区（1.8后改为元空间）。

- 虚拟机栈：是java执行方法的内存模型，是线程私有的，生命周期和线程相同。每个方法被执行的时候会创建栈帧，栈帧包括了执行方法的局部变量表（也是我们常说的java栈）、操作数栈、动态链接（持有运行时常量池中所属方法的引用）和方法返回地址的信息。方法执行时入栈，当方法正常返回或者抛出异常就会出栈。
- 本地方法栈：线程私有，和虚拟机栈类似，调用本地方法服务。
- 程序计数器：线程私有，记录当前线程执行的字节码的行号。任何时候，一个处理器也只能执行一个线程，如果当前线程被挂起了，处理器会执行其他的线程，当挂起的线程被唤醒是，程序通过程序计数器的行号就知道上次执行的位置了。
- 本地内存：线程共享区域，在java 8 中本地内存包括了元内存和直接内存，元内存替代了java7中的方法区，主要存储了类得信息、常量、静态变量和即时编译器编译后的代码等。从java8开始，也不需要GC。
  - 为什么取代了方法区，因为方法区有内存大小限制或者发生内存泄漏
- 堆：分配对象示例和数组，线程共享，主要垃圾回收的地方。

### 垃圾回收机制

#### 概念

​	垃圾回收即回收没有任何对象引用的对象（垃圾对象）所占据的内存空间。

#### 如何判别是垃圾对象

**引用计数法**

如果对象被引用一次就加一，没有引用就减一，如果为0则表示可以回收

```java
String s = new String("Java");
// 引用次数加1
s = null;
// 由于对象没被引用，引用次数置为0，由于不被其他对象引用，此时会被回收
```

存在的问题，循环引用

```java
public class TestRC {

    TestRC instance;
    public TestRC(String name) {
    }

    public static  void main(String[] args) {
        // 第一步 引用计数加一 1
	A a = new TestRC("a");
	B b = new TestRC("b");

        // 第二步 引用计数加二 2
	a.instance = b;
	b.instance = a;

        // 第三步 引用计数减一 1，出现循环引用
	a = null;
	b = null;
    }
}
```

**可达性算法**

以一系列叫做GC Root对象出发，引出它们指向的下一个节点，直到遍历所有节点，那些不以任何GC Root出发的对象会被回收。

**1.不可达的对象就一定会被回收吗？**

答案是否定的，当对象不可达时，发生GC时，会先判断对象是否执行了finalize方法，如果没有执行，则会先执行以下finalize方法，我们可以在这个方法中将当前对象与GC Roots关联,这样执行finalize方法后，GC会判断对象是否可达，如果不可达，则会被回收，可达，则不回收。需要注意的是finalize方法只能执行一次，如果执行一次后对象变成可达的并且不会被回收，那么该对象再次被GC时，会忽略finalize方法，直接回收。

**2.什么对象可以视为GC Root尼**

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

示例

**虚拟机栈中引用的对象**

如下代码，a是栈帧中的本地变量，a充当了GC Root的作用，当a=null，a与示例new Test()断开连接，所有对象被回收

```java
public class Test{
    public static void main(String .. args){
        Test a = new Test();
        a = null;
    }
}
```

**方法区中类静态属性引用的对象**

当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。

```java
public class Test {
    public static Test s;
    public static  void main(String[] args) {
	Test a = new Test();
	a.s = new Test();
	a = null;
    }
}
```

**方法区中常量引用的对象**

常量s指向的对象并不会因为a指向的对象回收而回收

```java
public class Test {
	public static final Test s = new Test();
        public static void main(String[] args) {
	    Test a = new Test();
	    a = null;
        }
}
```

#### **本地方法栈中 JNI 引用的对象**

当 java 调用本地方法时,只会在此本地方法执行完成后才会被释放。

#### 垃圾回收算法

**标记清除算法**：先标记可回收的对象，再对对象进行回收。

缺点：容易产生大量碎片

**复制算法**：把堆等分成两块区域,每次只使用一块区域，先清除不存活的对象，再把存活的对象复制到另一块上面，最后再清理所有原本存放对象的区域。

优点：解决了内存碎片问题

缺点：浪费空间，效率低下，每次回收都要移动存活对象到另一块上面。

**标记整理算法**：前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列（如图示），再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。

优点：不浪费空间

缺点：效率低下

**分代收集算法**：分代收集算法结合了上述算法的优点。看图下的对象分配的规律。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLUrYqPicjVwjuMChPrPicNHdXF1fErVNiaLrwenMuRFpxNLM7kJUJGhqYg1icRzbhEWOypZficqyyGbiaHw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

由图可以知道，大部分对象都是短命的，都是在很短的时间就被回收了。所以分代收集算法就是根据对象存活周期的不同将堆划分成新生代和老年代（java8前还有永久代），默认比例是1:2，新生区又分为Eden区，from Survivor区（s0），to survivor区（s1），默认比例是8:1:1。可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的GC 称作Young GC（也叫Minor GC），老年代发生的GC称Old GC（也称Full GC）。

**原理**

1. 对象在新生代的分配和回收流程

![image](https://user-images.githubusercontent.com/39090338/79440417-8bb1cb00-8008-11ea-8afa-76b709ad3d3f.png)

Eden区将满时，触发Minor GC

![image](https://user-images.githubusercontent.com/39090338/79440603-c9aeef00-8008-11ea-9afd-e73ae5345d27.png)

大部分对象在短时间内都会被回收, 所以经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（这就是为啥空间大小  Eden: S0: S1 = 8:1:1, Eden 区远大于 S0,S1 的原因，因为在 Eden 区触发的 Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，此时把它们移到 S0 或 S1 绰绰有余）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间。

![image](https://user-images.githubusercontent.com/39090338/79440754-f3681600-8008-11ea-891f-89f31139c8ac.png)

当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。

![image](https://user-images.githubusercontent.com/39090338/79440853-1397d500-8009-11ea-8f8c-eb3fdc0e4f17.png)

若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。也就是说在 Eden 区的垃圾回收我们采用的是**复制算法**，因为在 Eden 区分配的对象大部分在 Minor GC 后都消亡了，只剩下极少部分存活对象（这也是为啥 Eden:S0:S1 默认为 8:1:1 的原因），S0,S1 区域也比较小，所以最大限度地降低了复制算法造成的对象频繁拷贝带来的开销。

2. 对象晋升老年代
   - 当对象年龄达到阈值是（默认15），从s0或s1晋升老年代
   - 大对象 当某对象分配需要大量的连续内存时，直接分配给老年代
   - 还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。
3. 空间分配担保

在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。

4. stop thw world

如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。

什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。

![image](https://user-images.githubusercontent.com/39090338/79441553-f9aac200-8009-11ea-998c-ca72dfb90f57.png)

现在我们应该明白把新生代设置成 Eden, S0，S1区或者给对象设置年龄阈值或者默认把新生代与老年代的空间大小设置成 1:2 都是为了**尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC**。想想新生代如果只设置 Eden 会发生什么，后果就是每经过一次 Minor GC，存活对象会过早地进入老年代，那么老年代很快就会装满，很快会触发 Full GC，而对象其实在经过两三次的 Minor GC 后大部分都会消亡，所以有了 S0,S1的缓冲，只有少数的对象会进入老年代，老年代大小也就不会这么快地增长，也就避免了过早地触发 Full GC。

由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。Safe Point 主要指的是以下特定位置：

- 循环的末尾
- 方法返回前
- 调用方法的 call 之后
- 抛出异常的位置 另外需要注意的是由于新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法，而在老生代由于对象比较多，占用的空间较大，使用复制算法会有较大开销（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）所以根据老生代特点，在老年代进行的 GC 一般采用的是标记整理法来进行回收。

#### 垃圾收集器分类

![image](https://user-images.githubusercontent.com/39090338/79441873-5f974980-800a-11ea-9140-ceabfa3f12d3.png)

- 在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge
- 在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old
- 同时在新老生代工作的垃圾回收器：G1

### 新生代收集器

#### Serial 收集器

Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，不仅如此，还记得我们上文提到的 STW 了吗，它在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。

看起来单线程垃圾收集器不太实用，不过我们需要知道的任何技术的使用都不能脱离场景，在 **Client 模式**下，它简单有效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销，专心做 GC 能将其单线程的优势发挥到极致，另外在用户的桌面应用场景，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，所以对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器

#### ParNew 收集器

ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程，其他像收集算法,STW,对象分配规则，回收策略与 Serial 收集器完成一样，在底层上，这两种收集器也共用了相当多的代码，它的垃圾收集过程如下

![image](https://user-images.githubusercontent.com/39090338/79442211-d03e6600-800a-11ea-8432-487da5d5999e.png)

ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器，另一个与性能无关的原因是因为除了 Serial  收集器，**只有它能与 CMS 收集器配合工作**，CMS 是一个划时代的垃圾收集器，是真正意义上的**并发收集器**，它第一次实现了垃圾收集线程与用户线程（基本上）同时工作，它采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作，而后文提到的 Parallel Scavenge 与 G1 收集器没有使用传统的 GC 收集器代码框架，而是另起炉灶独立实现的，另外一些收集器则只是共用了部分的框架代码,所以无法与 CMS 收集器一起配合工作。

在多 CPU 的情况下，由于 ParNew 的多线程回收特性，毫无疑问垃圾收集会更快，也能有效地减少 STW 的时间，提升应用的响应速度。

#### Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一个使用**复制算法**，**多线程**，工作于新生代的垃圾收集器，看起来功能和 ParNew 收集器一样，它有啥特别之处吗

**关注点不同**，CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。

Parallel Scavenge 收集器提供了两个参数来精确控制吞吐量，分别是控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数及直接设置吞吐量大小的 -XX:GCTimeRatio（默认99%）

除了以上两个参数，还可以用 Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！

### 老年代收集器

#### Serial Old 收集器

上文我们知道， Serial 收集器是工作于新生代的单线程收集器，与之相对地，Serial Old 是工作于老年代的单线程收集器，此收集器的主要意义在于给 Client 模式下的虚拟机使用，如果在 Server 模式下，则它还有两大用途：一种是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，另一种是作为 CMS 收集器的后备预案,在并发收集发生 Concurrent Mode Failure 时使用（后文讲述）,它与 Serial 收集器配合使用示意图如下

![image](https://user-images.githubusercontent.com/39090338/79442381-0f6cb700-800b-11ea-8f2f-511a3299d405.png)

#### Parallel Old 收集器

Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本，使用多线程和标记整理法，两者组合示意图如下,这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标

![image](https://user-images.githubusercontent.com/39090338/79442438-1bf10f80-800b-11ea-9ca7-f699fe641a41.png)

#### CMS 收集器

CMS 收集器是以实现最短 STW 时间为目标的收集器，如果应用很重视服务的响应速度，希望给用户最好的体验，则 CMS 收集器是个很不错的选择！

我们之前说老年代主要用标记整理法，而 CMS 虽然工作于老年代，但采用的是标记清除法，主要有以下四个步骤

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

从图中可以的看到初始标记和重新标记两个阶段会发生 STW，造成用户线程挂起，不过初始标记仅标记 GC Roots 能关联的对象，速度很快，并发标记是进行 GC Roots  Tracing 的过程，重新标记是为了修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这一阶段停顿时间一般比初始标记阶段稍长，但**远比并发标记时间短**。

整个过程中耗时最长的是并发标记和标记清理，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，所以总体上看，可以认为 CMS 收集器的内存回收过程是与用户线程一起并发执行的。

![image](https://user-images.githubusercontent.com/39090338/79442582-522e8f00-800b-11ea-87ae-dfbd7df50b3e.png)

但是 CMS 收集器远达不到完美的程度，主要有以下三个缺点

- CMS 收集器对 CPU 资源非常敏感  原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%,显然是不可接受的
- CMS 无法处理浮动垃圾（Floating Garbage）,可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，由于在并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾），同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 **Concurrent Mode Failure** 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。
- CMS 采用的是标记清除法，上文我们已经提到这种方法会产生大量的内存碎片，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。当然我们可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。

#### G1（Garbage First） 收集器

G1 收集器是面向服务端的垃圾收集器，被称为驾驭一切的垃圾回收器，主要有以下几个特点

- 像 CMS 收集器一样，能与应用程序线程并发执行。

- 整理空闲空间更快。

- 需要 GC 停顿时间更好预测。

- 不会像 CMS 那样牺牲大量的吞吐性能。

- 不需要更大的 Java Heap

  

  与 CMS 相比，它在以下两个方面表现更出色

1. 运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。
2. 在 STW 上建立了**可预测**的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内。

为什么G1能建立可预测的停顿模型呢，主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一器，传统的内存分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下

![image](https://user-images.githubusercontent.com/39090338/79442737-886c0e80-800b-11ea-8dec-f795c79fb3b0.png)

而 G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，如图示

![image](https://user-images.githubusercontent.com/39090338/79442760-8c982c00-800b-11ea-80d0-d3d466059be1.png)

除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢？

传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。

G1 收集器的工作步骤如下

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

![image](https://user-images.githubusercontent.com/39090338/79442788-93bf3a00-800b-11ea-984e-b1f8ea81eb74.png)

> 注：本文参考原作者链接：[传送门](https://mp.weixin.qq.com/s/_AK手机Qs-xXDHlk84HbwKUzOw)