---
layout: post
title: JAVA锁升级过程
date: 2021-01-06
tags: java
---

#### 锁升级优化

为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上
下文切换，而正是新增的 Java 对象头实现了锁升级功能。
当 Java 对象被 Synchronized 关键字修饰成为同步锁后，围绕这个锁的一系列升级操作都
将和 Java 对象头有关。

##### Java 对象头

在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填
充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。
Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，
我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：

![image](https://user-images.githubusercontent.com/39090338/103765036-7c235800-5057-11eb-932a-6b9d60fe2f14.png)

锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，Synchronized 同
步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量
级锁。下面我们就沿着这条优化路径去看下具体的内容。

**流程图如下**

![image](https://user-images.githubusercontent.com/39090338/103768277-2fdb1680-505d-11eb-8468-07f691994142.png)

##### **偏向锁**

偏向锁主要用来优化同一线程多次申请同一个锁的竞争。在某些情况下，大部分时间是同一
个线程竞争锁资源，例如，在创建一个线程并在线程中执行循环监听的场景下，或单线程操
作一个线程安全集合时，同一线程每次都需要获取和释放锁，每次操作都会发生用户态与内
核态的切换。
偏向锁的作用就是，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头的
Mark Word 中去判断一下是否有偏向锁指向它的 ID，无需再进入 Monitor 去竞争对象
了。当对象被当做同步锁并有一个线程抢到了锁时，锁标志位还是 01，“是否偏向锁”标
志位设置为 1，并且记录抢到锁的线程 ID，表示进入偏向锁状态。
一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待全局安全点，
暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被
其它线程抢占。

因此，在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生
stop the word 后， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加 JVM
参数关闭偏向锁来调优系统性能，示例代码如下：

```java
-XX:-UseBiasedLocking // 关闭偏向锁（默认打开
-XX:+UseHeavyMonitors  // 设置重量级锁
```



##### 轻量级锁

当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 Mark Word
中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换
Mark Word 中的线程 ID 为自己的 ID，该锁会保持偏向锁状态；如果获取锁失败，代表当
前锁有一定的竞争，偏向锁将升级为轻量级锁。
轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时
间的竞争。

##### 自旋锁与重量级锁

轻量级锁 CAS 抢锁失败，线程将会被挂起进入阻塞状态。如果正在持有锁的线程在很短的
时间内释放资源，那么进入阻塞状态的线程无疑又要申请锁资源。
JVM 提供了一种自旋锁，可以通过自旋方式不断尝试获取锁，从而避免线程被挂起阻塞。
这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿
失。
从 JDK1.7 开始，自旋锁默认启用，自旋次数由 JVM 设置决定，这里我不建议设置的重试
次数过多，因为 CAS 重试操作意味着长时间地占用 CPU。
自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为 10。在这
个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中。

在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。一旦锁竞争激烈
或锁占用的时间过长，自旋锁将会导致大量的线程一直处于 CAS 重试状态，占用 CPU 资
源，反而会增加系统性能开销。所以自旋锁和重量级锁的使用都要结合实际场景。
在高负载、高并发的场景下，我们可以通过设置 JVM 参数来关闭自旋锁，优化系统性能，
示例代码如下：

```java
-XX:-UseSpinning // 参数关闭自旋锁优化 (默认打开) 
-XX:PreBlockSpin // 参数修改默认的自旋次数。JDK1.7 后，去掉此参数，由 jvm 控制
```

**动态编译实现锁消除 / 锁粗化**
除了锁升级优化，Java 还使用了编译器对锁进行优化。JIT 编译器在动态编译同步块的时
候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程
访问，而没有被发布到其它线程。
确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁
的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，
该操作可以自动实现。
锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁
实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反
复申请、释放同一个锁“所带来的性能开销。
**减小锁粒度**
除了锁内部优化和编译器优化之外，我们还可以通过代码层来实现锁优化，减小锁粒度就是
一种惯用的方法。
当我们的锁对象是一个数组或队列时，集中竞争一个对象的话会非常激烈，锁也会升级为重
量级锁。我们可以考虑将一个数组和队列对象拆成多个小对象，来降低锁竞争，提升并行
度。